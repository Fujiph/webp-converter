<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced WebP Converter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
          },
        },
      };
    </script>
    <!-- JSZip Library for "Download All" functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- FileSaver is often used with JSZip, though JSZip can manage download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
      /* Custom styles for better aesthetics */
      body {
        background-color: #f3f4f6;
      }
      .container-card {
        max-width: 900px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
        background-color: white;
      }
      /* Updated grid to include a 50px column for the preview image */
      .file-item-grid {
        /* Preview | Filename | Original Size | Converted Size | Actions (Download/Delete) */
        display: grid;
        grid-template-columns: 50px 2fr 1.5fr 1.5fr 120px;
        align-items: center;
        gap: 1rem;
        padding: 1rem 0;
        border-bottom: 1px solid #e5e7eb;
      }
      .file-item-grid:first-of-type {
        border-top: 1px solid #e5e7eb;
      }
      .file-item-grid:last-child {
        border-bottom: none;
      }
      .size-info span {
        display: block;
        font-size: 0.85rem;
        line-height: 1.3;
      }
      .preview-thumb {
        width: 40px;
        height: 40px;
        object-fit: contain;
        border-radius: 4px;
        border: 1px solid #e5e7eb;
      }
    </style>
  </head>
  <body
    class="font-sans min-h-screen flex items-start justify-center p-4 sm:p-8"
  >
    <div class="container-card w-full rounded-xl p-6 md:p-10 mt-8">
      <h1 class="text-3xl font-bold text-gray-900 mb-6 border-b pb-2">
        WebP Batch Converter
      </h1>
      <p class="text-gray-600 mb-6">
        Convert multiple JPG, PNG, or GIF images to WebP format directly in your
        browser with custom quality settings. Supports transparency for
        background-less images (PNG/GIF).
      </p>

      <!-- Configuration Controls -->
      <div class="bg-gray-50 p-6 rounded-lg mb-8 border border-gray-200">
        <h2 class="text-xl font-semibold mb-4 text-gray-800">
          Conversion Settings
        </h2>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Compression Mode -->
          <div>
            <label
              for="compression-mode"
              class="block text-sm font-medium text-gray-700 mb-2"
              >Compression Type</label
            >
            <select
              id="compression-mode"
              onchange="updateQualitySliderVisibility()"
              class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm"
            >
              <option value="lossy">Lossy (Smaller file size)</option>
              <option value="lossless">
                Lossless (Best quality, preserves transparency)
              </option>
            </select>
          </div>

          <!-- Quality Slider (Conditional visibility) -->
          <div id="quality-setting">
            <label
              for="quality-slider"
              class="block text-sm font-medium text-gray-700 mb-2"
            >
              Quality (1-100):
              <span id="quality-value" class="font-bold text-blue-600">85</span>
            </label>
            <input
              type="range"
              id="quality-slider"
              min="1"
              max="100"
              value="85"
              oninput="document.getElementById('quality-value').textContent = this.value"
              class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg"
            />
          </div>
        </div>
      </div>

      <!-- File Upload Area -->
      <div class="mb-8">
        <label
          for="image-upload"
          class="block text-lg font-medium text-gray-700 mb-4"
          >1. Select Images</label
        >
        <input
          type="file"
          id="image-upload"
          accept="image/png, image/jpeg, image/gif, image/webp"
          multiple
          class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"
        />
      </div>

      <!-- Conversion Button -->
      <button
        id="convert-btn"
        onclick="startConversion()"
        class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-150 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 disabled:opacity-50"
        disabled
      >
        2. Convert Selected Images to WebP
      </button>

      <!-- Results Area -->
      <div class="mt-10">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-semibold text-gray-800">
            Conversion Results
          </h2>
          <div class="flex space-x-3">
            <!-- Download All Button -->
            <button
              id="download-all-btn"
              onclick="downloadAll()"
              class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150 ease-in-out shadow-md disabled:opacity-50"
              disabled
            >
              Download All (.zip)
            </button>
            <!-- NEW: Clear All Results Button -->
            <button
              id="clear-all-btn"
              onclick="deleteAllFiles()"
              class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150 ease-in-out shadow-md disabled:opacity-50"
              disabled
            >
              Clear All Results
            </button>
          </div>
        </div>

        <div id="file-list" class="bg-white border rounded-lg overflow-hidden">
          <div class="p-4 text-center text-gray-500" id="initial-message">
            Files will appear here after conversion.
          </div>
        </div>
      </div>

      <!-- Error/Loading Message -->
      <div id="status-message" class="mt-4 text-center hidden"></div>
    </div>

    <script>
      // Global array to store successful conversion results (for Download All and per-file management)
      window.convertedFiles = [];
      const fileListDiv = document.getElementById("file-list");
      const statusMessage = document.getElementById("status-message");

      // Helper function to format file size in bytes, KB, MB
      function formatSize(bytes) {
        if (bytes === 0) return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes", "KB", "MB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
      }

      // Toggles the quality slider visibility based on the selected mode
      function updateQualitySliderVisibility() {
        const mode = document.getElementById("compression-mode").value;
        const qualitySettingDiv = document.getElementById("quality-setting");
        // Quality slider is only relevant for Lossy compression
        if (qualitySettingDiv) {
          qualitySettingDiv.style.display = mode === "lossy" ? "block" : "none";
        }
      }

      /**
       * The core conversion function using the browser's Canvas API.
       * @param {File} file - The input image file.
       * @param {number} quality - Quality factor (0.0 to 1.0) for lossy conversion.
       * @param {boolean} isLossless - Flag for lossless conversion.
       * @returns {Promise<{webpBlob: Blob, originalDataURL: string}>} A promise that resolves with the WebP Blob and original Data URL.
       */
      async function convertToWebP(file, quality, isLossless) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";

          // Read the file as a data URL first to store for preview and load into Image object
          const reader = new FileReader();
          reader.onerror = () => reject(new Error("File reading failed."));
          reader.onload = (e) => {
            const originalDataURL = e.target.result;
            img.src = originalDataURL;

            img.onload = () => {
              const canvas = document.createElement("canvas");
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext("2d");

              // Crucial for supporting transparency (no background image)
              ctx.drawImage(img, 0, 0);

              let targetQuality = isLossless ? 1.0 : quality / 100.0;

              canvas.toBlob(
                (blob) => {
                  if (blob && blob.type === "image/webp") {
                    resolve({ webpBlob: blob, originalDataURL });
                  } else if (blob) {
                    reject(
                      new Error(
                        `Browser failed to encode as WebP (Mime type: ${blob.type}).`
                      )
                    );
                  } else {
                    reject(
                      new Error(
                        "Unknown conversion error: Canvas.toBlob returned null."
                      )
                    );
                  }
                },
                "image/webp",
                targetQuality
              );
            };

            img.onerror = () => {
              reject(new Error(`Could not load image file: ${file.name}`));
            };
          };
          reader.readAsDataURL(file);
        });
      }

      /**
       * Renders the results list and the total summary based on window.convertedFiles.
       */
      function renderResultsAndSummary() {
        const downloadAllBtn = document.getElementById("download-all-btn");
        const clearAllBtn = document.getElementById("clear-all-btn");
        const files = window.convertedFiles;

        if (files.length === 0) {
          fileListDiv.innerHTML = `<div class="p-4 text-center text-gray-500" id="initial-message">Files will appear here after conversion.</div>`;
          if (downloadAllBtn) downloadAllBtn.disabled = true;
          if (clearAllBtn) clearAllBtn.disabled = true;
          return;
        }

        if (downloadAllBtn) downloadAllBtn.disabled = false;
        if (clearAllBtn) clearAllBtn.disabled = false;

        let totalOriginalSize = 0;
        let totalConvertedSize = 0;
        const resultsHtml = [];

        // Add Header Row
        resultsHtml.push(`
                <div class="file-item-grid px-4 py-2 bg-gray-100 font-bold text-sm text-gray-700">
                    <span class="text-center"></span>
                    <span>Filename</span>
                    <span>Original Size</span>
                    <span>Converted Size</span>
                    <span class="text-center">Actions</span>
                </div>
            `);

        files.forEach((fileData) => {
          const {
            originalFile,
            webpBlob,
            originalDataURL,
            webpFileName,
            quality,
            isLossless,
          } = fileData;
          const originalSize = originalFile.size;
          const convertedSize = webpBlob.size;

          totalOriginalSize += originalSize;
          totalConvertedSize += convertedSize;

          // Calculate size difference
          const sizeDiff = originalSize - convertedSize;
          const percentageReduction = ((sizeDiff / originalSize) * 100).toFixed(
            2
          );

          // Create download link
          const downloadUrl = URL.createObjectURL(webpBlob);

          // Determine color for size difference
          let diffColor, diffText;
          if (sizeDiff > 0) {
            diffColor = "text-green-600";
            diffText = `Reduced by ${formatSize(
              sizeDiff
            )} (${percentageReduction}%)`;
          } else {
            diffColor = "text-red-500";
            diffText = `Size Increased by ${formatSize(
              Math.abs(sizeDiff)
            )} (${Math.abs(percentageReduction)}%)`;
          }

          resultsHtml.push(`
                    <div class="file-item-grid px-4" id="row-${webpFileName.replace(
                      /\./g,
                      ""
                    )}">
                        <img src="${originalDataURL}" alt="Preview" class="preview-thumb">
                        <span class="font-medium truncate">${
                          originalFile.name
                        }</span>
                        <div class="size-info text-gray-500">
                            <span>${formatSize(originalSize)}</span>
                            <span>Mode: ${
                              isLossless ? "Lossless" : `Lossy (${quality}%)`
                            }</span>
                        </div>
                        <div class="size-info text-gray-800 font-semibold">
                            <span>${formatSize(convertedSize)}</span>
                            <span class="${diffColor}">${diffText}</span>
                        </div>
                        <div class="flex flex-col space-y-1">
                            <a href="${downloadUrl}" download="${webpFileName}" 
                                class="text-white bg-blue-600 hover:bg-blue-700 py-1.5 px-2 rounded-lg text-xs font-semibold text-center transition duration-150">
                                Download
                            </a>
                            <button onclick="deleteFile('${webpFileName}')"
                                class="bg-red-500 hover:bg-red-600 text-white py-1.5 px-2 rounded-lg text-xs transition duration-150">
                                Delete
                            </button>
                        </div>
                    </div>
                `);
        });

        // Calculate total summary
        const totalDiff = totalOriginalSize - totalConvertedSize;
        const totalReductionPercent =
          totalOriginalSize > 0
            ? ((totalDiff / totalOriginalSize) * 100).toFixed(2)
            : 0;

        let totalDiffColor, totalDiffText;
        if (totalDiff >= 0) {
          totalDiffColor = "text-green-600";
          totalDiffText = `Total Reduction: ${formatSize(
            totalDiff
          )} (${totalReductionPercent}%)`;
        } else {
          totalDiffColor = "text-red-500";
          totalDiffText = `Total Increase: ${formatSize(
            Math.abs(totalDiff)
          )} (${Math.abs(totalReductionPercent)}%)`;
        }

        // Display overall summary
        const summaryHtml = `
                <div class="file-item-grid px-4 py-4 bg-gray-100 font-bold border-t-2 border-gray-300">
                    <span class="text-center"></span>
                    <span>TOTAL SUMMARY (${files.length} Files)</span>
                    <div class="size-info text-gray-700">
                        ${formatSize(totalOriginalSize)}
                    </div>
                    <div class="size-info text-gray-900">
                        ${formatSize(totalConvertedSize)}
                        <span class="${totalDiffColor} font-normal text-xs mt-1">${totalDiffText}</span>
                    </div>
                    <span></span>
                </div>
            `;

        fileListDiv.innerHTML = resultsHtml.join("");
        fileListDiv.insertAdjacentHTML("beforeend", summaryHtml);
      }

      /**
       * Deletes a single file from the list and recalculates the summary.
       * @param {string} fileName - The unique WebP filename to delete.
       */
      function deleteFile(fileName) {
        // Find the index of the file to delete
        const index = window.convertedFiles.findIndex(
          (f) => f.webpFileName === fileName
        );

        if (index > -1) {
          // Remove the file from the array
          window.convertedFiles.splice(index, 1);

          // Update the UI
          renderResultsAndSummary();

          // Optional: Show status message
          if (statusMessage) {
            statusMessage.textContent = `Deleted ${fileName}. Results updated.`;
            statusMessage.className =
              "mt-4 text-center text-orange-500 font-medium";
          }
        }
      }

      /**
       * Clears all converted files and resets the results area.
       */
      function deleteAllFiles() {
        if (window.convertedFiles.length > 0) {
          // Clear the array
          window.convertedFiles = [];

          // Update the UI
          renderResultsAndSummary();

          // Reset file input value
          const fileInput = document.getElementById("image-upload");
          if (fileInput) fileInput.value = "";

          // Reset button state and status
          const convertBtn = document.getElementById("convert-btn");
          if (convertBtn) convertBtn.disabled = true;

          if (statusMessage) {
            statusMessage.textContent =
              "All converted results have been cleared.";
            statusMessage.className =
              "mt-4 text-center text-orange-500 font-bold";
          }
        }
      }

      // Function to handle downloading all converted files as a ZIP
      async function downloadAll() {
        const statusMessage = document.getElementById("status-message");
        const downloadAllBtn = document.getElementById("download-all-btn");

        if (window.convertedFiles.length === 0) {
          if (statusMessage) {
            statusMessage.textContent =
              "No files were successfully converted to download.";
            statusMessage.className =
              "mt-4 text-center text-red-500 font-medium";
          }
          return;
        }

        downloadAllBtn.disabled = true;
        if (statusMessage) {
          statusMessage.textContent = "Creating ZIP archive... Please wait.";
          statusMessage.className =
            "mt-4 text-center text-blue-500 font-medium";
          statusMessage.classList.remove("hidden");
        }

        const zip = new JSZip();

        window.convertedFiles.forEach((fileData) => {
          const fileName = fileData.webpFileName;
          const blob = fileData.webpBlob;
          zip.file(fileName, blob);
        });

        try {
          const content = await zip.generateAsync({ type: "blob" });

          // Use FileSaver.js (saveAs) to trigger the download
          saveAs(
            content,
            `webp-batch-conversion_${new Date().toISOString().slice(0, 10)}.zip`
          );

          if (statusMessage) {
            statusMessage.textContent = `ZIP archive created and download started!`;
            statusMessage.className =
              "mt-4 text-center text-green-600 font-bold";
          }
        } catch (error) {
          if (statusMessage) {
            statusMessage.textContent = `Error creating ZIP: ${error.message}`;
            statusMessage.className =
              "mt-4 text-center text-red-500 font-medium";
          }
        } finally {
          downloadAllBtn.disabled = false;
        }
      }

      // Main conversion function triggered by the button
      async function startConversion() {
        const fileInput = document.getElementById("image-upload");
        const convertBtn = document.getElementById("convert-btn");

        const quality = parseInt(
          document.getElementById("quality-slider").value
        );
        const mode = document.getElementById("compression-mode").value;
        const isLossless = mode === "lossless";

        const files = Array.from(fileInput.files);

        if (files.length === 0) {
          if (statusMessage) {
            statusMessage.textContent = "Please select files first.";
            statusMessage.className = "mt-4 text-center text-red-500";
            statusMessage.classList.remove("hidden");
          }
          return;
        }

        // UI Feedback: Loading
        convertBtn.disabled = true;
        if (statusMessage) {
          statusMessage.textContent = `Converting ${files.length} file(s)...`;
          statusMessage.className =
            "mt-4 text-center text-blue-500 font-medium";
          statusMessage.classList.remove("hidden");
        }
        if (fileListDiv) {
          fileListDiv.innerHTML = `<div class="p-4 text-center text-blue-500" id="processing-message">Processing...</div>`;
        }

        window.convertedFiles = [];

        for (const originalFile of files) {
          try {
            const { webpBlob, originalDataURL } = await convertToWebP(
              originalFile,
              quality,
              isLossless
            );

            const webpFileName =
              originalFile.name.replace(/\.[^/.]+$/, "") + ".webp";

            // Store successful conversion results
            window.convertedFiles.push({
              originalFile,
              webpBlob,
              originalDataURL,
              webpFileName,
              quality,
              isLossless,
            });
          } catch (error) {
            const errorHtml = `
                        <div class="file-item-grid px-4">
                            <span class="text-center text-red-600">!</span>
                            <span class="font-medium text-red-600 col-span-4">${originalFile.name} (Error: ${error.message})</span>
                        </div>
                    `;
            // Temporarily append error message until the final render
            if (fileListDiv) fileListDiv.innerHTML += errorHtml;
          }
        }

        // Render all successful results and summary at once
        renderResultsAndSummary();

        // UI Feedback: Done
        if (statusMessage) {
          statusMessage.textContent = `Conversion complete! Processed ${files.length} file(s). ${window.convertedFiles.length} successful conversions ready for download.`;
          statusMessage.className = "mt-4 text-center text-green-600 font-bold";
        }
        convertBtn.disabled = false;
      }

      // --- FIX: Ensure DOM elements are loaded before attaching listeners ---
      document.addEventListener("DOMContentLoaded", () => {
        updateQualitySliderVisibility();

        // Toggles the convert button and handles file selection state
        const imageUpload = document.getElementById("image-upload");
        const convertBtn = document.getElementById("convert-btn");
        const initialMessage = document.getElementById("initial-message");
        const fileListDiv = document.getElementById("file-list");

        if (imageUpload) {
          imageUpload.addEventListener("change", function () {
            const files = this.files;
            if (convertBtn) {
              convertBtn.disabled = files.length === 0;
            }
            if (initialMessage) {
              initialMessage.textContent =
                files.length > 0
                  ? `Ready to convert ${files.length} file(s).`
                  : `Files will appear here after conversion.`;
            }
            if (fileListDiv) {
              // Reset the result list back to the initial message when new files are selected
              fileListDiv.innerHTML = `<div class="p-4 text-center text-gray-500" id="initial-message">${
                initialMessage
                  ? initialMessage.textContent
                  : "Files will appear here after conversion."
              }</div>`;
            }
            // Disable download/clear buttons immediately on new file selection
            const downloadAllBtn = document.getElementById("download-all-btn");
            const clearAllBtn = document.getElementById("clear-all-btn");
            if (downloadAllBtn) downloadAllBtn.disabled = true;
            if (clearAllBtn) clearAllBtn.disabled = true;
          });
        }
      });
      // --- END FIX ---
    </script>
  </body>
</html>
